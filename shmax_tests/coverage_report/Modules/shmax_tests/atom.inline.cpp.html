<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>atom.inline.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
//_/_/
//_/_/ AERA
//_/_/ Autocatalytic Endogenous Reflective Architecture
//_/_/ 
//_/_/ Copyright (c) 2018-2025 Jeff Thompson
//_/_/ Copyright (c) 2018-2025 Kristinn R. Thorisson
//_/_/ Copyright (c) 2018-2025 Icelandic Institute for Intelligent Machines
//_/_/ http://www.iiim.is
//_/_/ 
//_/_/ Copyright (c) 2010-2012 Eric Nivel
//_/_/ Center for Analysis and Design of Intelligent Agents
//_/_/ Reykjavik University, Menntavegur 1, 102 Reykjavik, Iceland
//_/_/ http://cadia.ru.is
//_/_/ 
//_/_/ Part of this software was developed by Eric Nivel
//_/_/ in the HUMANOBS EU research project, which included
//_/_/ the following parties:
//_/_/
//_/_/ Autonomous Systems Laboratory
//_/_/ Technical University of Madrid, Spain
//_/_/ http://www.aslab.org/
//_/_/
//_/_/ Communicative Machines
//_/_/ Edinburgh, United Kingdom
//_/_/ http://www.cmlabs.com/
//_/_/
//_/_/ Istituto Dalle Molle di Studi sull'Intelligenza Artificiale
//_/_/ University of Lugano and SUPSI, Switzerland
//_/_/ http://www.idsia.ch/
//_/_/
//_/_/ Institute of Cognitive Sciences and Technologies
//_/_/ Consiglio Nazionale delle Ricerche, Italy
//_/_/ http://www.istc.cnr.it/
//_/_/
//_/_/ Dipartimento di Ingegneria Informatica
//_/_/ University of Palermo, Italy
//_/_/ http://diid.unipa.it/roboticslab/
//_/_/
//_/_/
//_/_/ --- HUMANOBS Open-Source BSD License, with CADIA Clause v 1.0 ---
//_/_/
//_/_/ Redistribution and use in source and binary forms, with or without
//_/_/ modification, is permitted provided that the following conditions
//_/_/ are met:
//_/_/ - Redistributions of source code must retain the above copyright
//_/_/   and collaboration notice, this list of conditions and the
//_/_/   following disclaimer.
//_/_/ - Redistributions in binary form must reproduce the above copyright
//_/_/   notice, this list of conditions and the following disclaimer 
//_/_/   in the documentation and/or other materials provided with 
//_/_/   the distribution.
//_/_/
//_/_/ - Neither the name of its copyright holders nor the names of its
//_/_/   contributors may be used to endorse or promote products
//_/_/   derived from this software without specific prior 
//_/_/   written permission.
//_/_/   
//_/_/ - CADIA Clause: The license granted in and to the software 
//_/_/   under this agreement is a limited-use license. 
//_/_/   The software may not be used in furtherance of:
//_/_/    (i)   intentionally causing bodily injury or severe emotional 
//_/_/          distress to any person;
//_/_/    (ii)  invading the personal privacy or violating the human 
//_/_/          rights of any person; or
//_/_/    (iii) committing or preparing for any act of war.
//_/_/
//_/_/ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
//_/_/ CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
//_/_/ INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
//_/_/ MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
//_/_/ DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
//_/_/ CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//_/_/ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
//_/_/ BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//_/_/ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
//_/_/ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
//_/_/ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
//_/_/ NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
//_/_/ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
//_/_/ OF SUCH DAMAGE.
//_/_/ 
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

#include &lt;iostream&gt;
namespace r_code {

<span style = "background-color:#fdd">inline Atom Atom::Float(float32 f) {</span>

<span style = "background-color:#fdd">  float32 _f = f;
  uint32 a = *reinterpret_cast&lt;uint32 *&gt;(&amp;_f);
  return Atom(a &gt;&gt; 1);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::PlusInfinity() {</span>

<span style = "background-color:#fdd">  return Atom(0x3FC00000);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::MinusInfinity() {</span>

<span style = "background-color:#fdd">  return Atom(0x7FC00000);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::UndefinedFloat() {</span>

<span style = "background-color:#fdd">  return Atom(0xFFFFFFF);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Nil() {</span>

<span style = "background-color:#fdd">  return Atom((uint32)(NIL &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Boolean(bool value) {</span>

<span style = "background-color:#fdd">  return Atom((BOOLEAN_ &lt;&lt; 24) + value);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::UndefinedBoolean() {</span>

<span style = "background-color:#fdd">  return Atom(0x81FFFFFF);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Wildcard(uint16 opcode) {</span>

<span style = "background-color:#fdd">  return Atom((WILDCARD &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::TailWildcard() {</span>

<span style = "background-color:#fdd">  return Atom((uint32)(T_WILDCARD &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::IPointer(uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((I_PTR &lt;&lt; 24) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::VLPointer(uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((VL_PTR &lt;&lt; 24) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::RPointer(uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((R_PTR &lt;&lt; 24) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::IPGMPointer(uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((IPGM_PTR &lt;&lt; 24) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::InObjPointer(uint8 input_index, uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((IN_OBJ_PTR &lt;&lt; 24) + (input_index &lt;&lt; 12) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::DInObjPointer(uint8 relative_index, uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((D_IN_OBJ_PTR &lt;&lt; 24) + (relative_index &lt;&lt; 12) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::OutObjPointer(uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((OUT_OBJ_PTR &lt;&lt; 24) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::ValuePointer(uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((VALUE_PTR &lt;&lt; 24) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::ProductionPointer(uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((PROD_PTR &lt;&lt; 24) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::AssignmentPointer(uint8 variable_index, uint16 index) {</span>

<span style = "background-color:#fdd">  return Atom((ASSIGN_PTR &lt;&lt; 24) + (variable_index &lt;&lt; 16) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::CodeVLPointer(uint16 index, uint16 cast_opcode) {</span>

<span style = "background-color:#fdd">  return Atom((CODE_VL_PTR &lt;&lt; 24) + ((cast_opcode &amp; 0x0FFF) &lt;&lt; 12) + (index &amp; 0x0FFF));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::This() {</span>

<span style = "background-color:#fdd">  return Atom((uint32)(THIS &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::View() {</span>

<span style = "background-color:#fdd">  return Atom((uint32)(VIEW &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Mks() {</span>

<span style = "background-color:#fdd">  return Atom((uint32)(MKS &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Vws() {</span>

<span style = "background-color:#fdd">  return Atom((uint32)(VWS &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::SSet(uint16 opcode, uint8 element_count) {</span>

<span style = "background-color:#fdd">  return Atom((S_SET &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + element_count);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Set(uint8 element_count) {</span>

<span style = "background-color:#fdd">  return Atom((SET &lt;&lt; 24) + element_count);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::CPointer(uint8 element_count) {</span>

<span style = "background-color:#fdd">  return Atom((C_PTR &lt;&lt; 24) + element_count);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Object(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((OBJECT &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Marker(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((MARKER &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Operator(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((OPERATOR &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Node(uint8 node_id) {</span>

<span style = "background-color:#fdd">  return Atom((NODE &lt;&lt; 24) + (node_id &lt;&lt; 8));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::UndefinedNode() {</span>

<span style = "background-color:#fdd">  return Atom(0xA0FFFFFF);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Device(uint8 node_id, uint8 class_id, uint8 dev_id) {</span>

<span style = "background-color:#fdd">  return Atom((DEVICE &lt;&lt; 24) + (node_id &lt;&lt; 16) + (class_id &lt;&lt; 8) + dev_id);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::UndefinedDevice() {</span>

<span style = "background-color:#fdd">  return Atom(0xA1FFFFFF);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::DeviceFunction(uint16 opcode) {</span>

<span style = "background-color:#fdd">  return Atom((DEVICE_FUNCTION &lt;&lt; 24) + (opcode &lt;&lt; 8));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::UndefinedDeviceFunction() {</span>

<span style = "background-color:#fdd">  return Atom(0xA2FFFFFF);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::String(uint8 character_count) {</span>

<span style = "background-color:#fdd">  uint8 blocks = character_count / 4;
  if (character_count % 4)
    ++blocks;
  return Atom((STRING &lt;&lt; 24) + (blocks &lt;&lt; 8) + character_count);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::UndefinedString() {</span>

<span style = "background-color:#fdd">  return Atom(0xC6FFFFFF);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Timestamp() {</span>

<span style = "background-color:#fdd">  return Atom((uint32)(TIMESTAMP &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::UndefinedTimestamp() {</span>

<span style = "background-color:#fdd">  return Atom(0xC7FFFFFF);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Duration() {
  return Atom((uint32)(DURATION &lt;&lt; 24));
}</span>

<span style = "background-color:#fdd">inline Atom Atom::InstantiatedProgram(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((INSTANTIATED_PROGRAM &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Group(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((GROUP &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::InstantiatedCPPProgram(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((INSTANTIATED_CPP_PROGRAM &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::InstantiatedAntiProgram(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((INSTANTIATED_ANTI_PROGRAM &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::InstantiatedInputLessProgram(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((INSTANTIATED_INPUT_LESS_PROGRAM &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::CompositeState(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((COMPOSITE_STATE &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::Model(uint16 opcode, uint8 arity) {</span>

<span style = "background-color:#fdd">  return Atom((MODEL &lt;&lt; 24) + ((opcode &amp; 0x0FFF) &lt;&lt; 8) + arity);
}</span>

<span style = "background-color:#fdd">inline Atom Atom::NullProgram(bool take_past_inputs) {</span>

<span style = "background-color:#fdd">  return Atom((NULL_PROGRAM &lt;&lt; 24) + (take_past_inputs ? 1 : 0));
}</span>

// RawPointer is not used. In any case, only define it for ARCH_32. If we want to
// define it for ARCH_64, we need to change the byte code to use two uint32 code elements.
#if defined ARCH_32
<span style = "background-color:#fdd">inline Atom Atom::RawPointer(void *pointer) {</span>

<span style = "background-color:#fdd">  return Atom((uint32)pointer);
}</span>
#endif

<span style = "background-color:#fdd">inline Atom::Atom(uint32 a) : atom_(a) {
}</span>

<span style = "background-color:#fdd">inline Atom::~Atom() {
}</span>

<span style = "background-color:#fdd">inline Atom &amp;Atom::operator =(const Atom&amp; a) {</span>

<span style = "background-color:#fdd">  atom_ = a.atom_;
  return *this;
}</span>

<span style = "background-color:#fdd">inline bool Atom::operator ==(const Atom&amp; a) const {</span>

<span style = "background-color:#fdd">  return atom_ == a.atom_;
}</span>

<span style = "background-color:#fdd">inline bool Atom::operator !=(const Atom&amp; a) const {</span>

<span style = "background-color:#fdd">  return atom_ != a.atom_;
}</span>

<span style = "background-color:#fdd">inline bool Atom::operator !() const {</span>

<span style = "background-color:#fdd">  return isUndefined();
}</span>

<span style = "background-color:#fdd">inline Atom::operator size_t () const {</span>

<span style = "background-color:#fdd">  return (size_t)atom_;
}</span>

<span style = "background-color:#fdd">inline bool Atom::isUndefined() const {</span>

<span style = "background-color:#fdd">  return atom_ == 0xFFFFFFFF;
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::getDescriptor() const {</span>

<span style = "background-color:#fdd">  return atom_ &gt;&gt; 24;
}</span>

<span style = "background-color:#fdd">inline bool Atom::isStructural() const {</span>

<span style = "background-color:#fdd">  return ((atom_ &amp; 0xC0000000) == 0xC0000000 || (atom_ &amp; 0xD0000000) == 0xD0000000);
}</span>

<span style = "background-color:#fdd">inline bool Atom::isFloat() const {</span>

<span style = "background-color:#fdd">  return atom_ &gt;&gt; 31 == 0;
}</span>

<span style = "background-color:#fdd">inline bool Atom::readsAsNil() const {</span>

<span style = "background-color:#fdd">  return atom_ == 0x80000000 ||</span>
    atom_ == 0x3FFFFFFF ||
    atom_ == 0x81FFFFFF ||
    atom_ == 0xC1000000 ||
    atom_ == 0xA0FFFFFF ||
    atom_ == 0xA1FFFFFF ||
    atom_ == 0xA2FFFFFF ||
    atom_ == 0xC6FFFFFF;
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">inline float32 Atom::asFloat() const {</span>

<span style = "background-color:#fdd">  uint32 _f = atom_ &lt;&lt; 1;
  return *reinterpret_cast&lt;const float32 *&gt;(&amp;_f);
}</span>

<span style = "background-color:#fdd">inline bool Atom::asBoolean() const {</span>

<span style = "background-color:#fdd">  return atom_ &amp; 0x000000FF;
}</span>

<span style = "background-color:#fdd">inline bool Atom::isBooleanTrue() const { return getDescriptor() == BOOLEAN_ &amp;&amp; asBoolean(); }</span>

<span style = "background-color:#fdd">inline bool Atom::isBooleanFalse() const { return getDescriptor() == BOOLEAN_ &amp;&amp; !asBoolean(); }</span>

<span style = "background-color:#fdd">inline uint16 Atom::asIndex() const {</span>

<span style = "background-color:#fdd">  return atom_ &amp; 0x00000FFF;
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::asInputIndex() const {</span>

<span style = "background-color:#fdd">  return (uint8)((atom_ &amp; 0x000FF000) &gt;&gt; 12);
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::asRelativeIndex() const {</span>

<span style = "background-color:#fdd">  return (uint8)((atom_ &amp; 0x000FF000) &gt;&gt; 12);
}</span>

<span style = "background-color:#fdd">inline uint16 Atom::asOpcode() const {</span>

<span style = "background-color:#fdd">  return (atom_ &gt;&gt; 8) &amp; 0x00000FFF;
}</span>

<span style = "background-color:#fdd">inline uint16 Atom::asCastOpcode() const {</span>

<span style = "background-color:#fdd">  return (uint16)((atom_ &amp; 0x00FFF000) &gt;&gt; 12);
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::getNodeID() const {</span>

<span style = "background-color:#fdd">  return (uint8)((atom_ &amp; 0x00FF0000) &gt;&gt; 16);
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::getClassID() const {</span>

<span style = "background-color:#fdd">  return (uint8)((atom_ &amp; 0x0000FF00) &gt;&gt; 8);
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::getDeviceID() const {</span>

<span style = "background-color:#fdd">  return (uint8)(atom_ &amp; 0x000000FF);
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::asAssignmentIndex() const {</span>

<span style = "background-color:#fdd">  return (uint8)((atom_ &amp; 0x00FF0000) &gt;&gt; 16);
}</span>

<span style = "background-color:#fdd">inline uint8 Atom::getAtomCount() const {</span>

<span style = "background-color:#fdd">  switch (getDescriptor()) {</span>
  case SET:
  case OBJECT:
  case MARKER:
  case C_PTR:
  case OPERATOR:
  case INSTANTIATED_PROGRAM:
  case INSTANTIATED_CPP_PROGRAM:
  case INSTANTIATED_INPUT_LESS_PROGRAM:
  case INSTANTIATED_ANTI_PROGRAM:
  case COMPOSITE_STATE:
  case MODEL:
  case GROUP:
<span style = "background-color:#fdd">  case S_SET: return atom_ &amp; 0x000000FF;
  case STRING: return (atom_ &amp; 0x0000FF00) &gt;&gt; 8;
  case TIMESTAMP: return 2;
  case DURATION: return 2;</span>
  default:
<span style = "background-color:#fdd">    return 0;</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">inline bool Atom::takesPastInputs() const {</span>

<span style = "background-color:#fdd">  return atom_ &amp; 0x00000001;
}</span>
}</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>